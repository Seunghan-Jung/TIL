# Java

## Java 버전의 차이

- **Java SE**
  - 자바 표준 플랫폼
  - 자바의 모든 기본 문법 및 API를 제공
  - 다른 버전 플랫폼은 SE를 기준으로 기능을 추가하거나 성격에 맞게 약간 변형한 것들
- **Java EE (J2EE)**
  - 서버 기능 개발을 위한 플랫폼
  - SE를 바탕으로 웹 앱 서버가 필요로 하는 기능들을 추가
  - 대표적 기능 : JSP, Servlet, EJB, JMS 등

## Java의 특징

1. 쉬운 문법을 제공

2. 자바는 독립적인 언어
   - JVM이라는 가상 서버 위에서 동작
   - 어떤 OS에서 실행하든 재컴파일하거나 시스템 라이브러리에 맞게 다시 작성할 필요가 없다.
   - 단, 반대로 그 만큼 컴퓨터의 리소스를 차지
3. GC(Garbage Collector)
   - 메모리의 반환을 신경 쓸 필요 없다
   - 성능을 높이기 위해 GC를 튜닝하기도 한다
4. 객체지향언어
5. 멀티 스레드 프로그래밍
   - 멀티 스레드 프로그래밍을 할 수 있도록 JDK에서 라이브러리를 제공
6. 수 많은 오픈소스
   - Apache Commons : 자바 개발에 편리한 기능들을 라이브러리 형태의 컴포넌트로 제공
   - Spring : 서버 프레임워크
   - Lucene : 자바 기반의 검색 엔진
   - 카산드라 : No-SQL 데이터베이스
   - 하둡 : 대량의 데이터를 여러 대의 컴퓨터가 처리 할 수 있도록 하는 분산 파일 시스템

## JVM

> Write once, run everywhere

- 물론, OS에 따라 서로 다른 JVM이 개발되어 있다.
- JVM은 메모리와 CPU 사용을 차지하기 때문에 성능 이슈가 있다.
- 시스템 함수를 이용할려면 JNI를 통해서 JVM을 한 번 더 거쳐야 하므로 성능 이슈 발생
- 하지만 하드웨어 성능이 올라가고, 자바 버전이 올라가면서 JVM 성능에 대한 이슈 줄어듬.
- 오히려 JAVA의 개발 편리와 생산성에 더 주목

### JVM의 동작 원리

- 클래스 파일

- 클래스 로더( 서브 시스템)

- 실행 데이터 영역

  실행 도중 필요한 데이터를 저장하는 영역

  아래 5가지 영역으로 구분

  - 메소드 영역 : 로딩된 클래스 저장

  - 스택 영역 : 실행된 메소드 저장

  - 힙 영역 : 실행된 클래스(객체) 저장

    GC가 데이터를 삭제하는 알고리즘은 힙의 세부 영역에 따라 다르게 적용

    - Young : 새롭게 생긴 데이터가 저장
    - Old : Young의 데이터가 빈번하게 사용되면 Old 영역으로 이동
    - Permanent : 클래스에 대한 정보가 저장(객체를 빠르게 생성하기 위해)

    > 힙 영역을 세 가지로 나누는 이유
    >
    > - 효율적 데이터 관리
    > - STW(Stop The World)를 줄이기 위함
    >   - STW : GC가 실행되는 동안 JVM의 다른 기능들이 잠시 멈춤
    >   - 데이터를 지우는 도중 다른 곳에서 그 데이터를 참조하려고하면 문제가 발생하기 때문에 이를 막기 위함.
    >   - 

  - 레지스터 영역 : JVM이 수행할 명령어의 주소를 저장하는 메모리 공간

  - 네이티브 메소드 영역 : JNI API를 사용하면 OS 시스템 접근이 가능한데, 이때 사용하는 네이티브 메소드들에 대한 정보가 저장

### 동적 클래스 로딩

- 로드타임 동적 로딩
  - 어떤 클래스를 로딩하는 시점에 해당 클래스가 참조하고 있는 다른 클래스를 로드
- 런타임 동적 로딩
  - 컴파일 시점에는 필요한 클래스인지 전혀 알 수 없는 경우에 런타임에 로드.
  - 예) 사용자가 입력한 이름의 클래스를 필요로 할 때(사용자의 입력을 받기 전까지는 무슨 클래스가 필요한지 알 수 없다.)
  - 

## 객체지향 프로그래밍

### 객체 VS 인스턴스

객체는 인스턴스의 한 종류(객체 $\subset$ 인스턴스)

객체가 실제 메모리에 올라가 데이터가 되는 것을 '인스턴스화'라고 한다.

### 상속

- 장점
  - 부모 클래스의 코드를 재활용
  - 클래스 기능 테스트의 효율성 증가
    - 재정의하지 않고 상속 받은 메서드라면 부모 클래스에서 테스트만 하면 된다
    - 상속을 받으면 재타이핑 할 필요도 없이 자동으로 코드를 재사용하므로 정확성도 높아진다.
  - 유지보수성이 좋다
    - 상속 받은 메서드들을 수정할 일이 있다면 부모의 메서드 하나만 수정하면 된다.

### 다형성

#### 메서드의 다형성

- 오버로딩
  - 같은 이름의 메서드를 여러 타입의 매개변수로 정의하는 것
  -  

> 객체끼리 비교
>
> | `==`                                                         | `.equals()`           | `instanceof`                    |
> | ------------------------------------------------------------ | --------------------- | ------------------------------- |
> | JVM 상 메모리 주소가 같은 경우, 즉 완전히 동일한 데이터(객체) | 데이터 값이 같은 경우 | 해당 클래스의 인스턴스인지 확인 |

## 제어자

### 접근제어자

| 접근 제어자 | -    |
| ----------- | ---- |
| public      |      |
| protected   |      |
| default     |      |
| private     |      |

### final

- 변수 : 변수의 데이터가 변경 될 수 없음
- 메서드 : 더이상 오버라이딩 할 수 없음, 즉 재정의 할 수 없음
- 클래스 : 더이상 상속될 수 없음, 마지막 자식 클래스임

### static

메모리에 단 하나만 존재해야할 때 사용하는 키워드

> #### 보통 `static`과 `final`을 같이 쓰는 이유
>
> ----
>
> static 키워드의 데이터는 메모리 상 하나만 존재하기 때문에 여러 객체가 동시다발적으로 이를 수정하는 일이 발생하면 데이터의 결과가 의도와 다르게 나올 수 있다. 따라서 static 데이터는 수정할 수 없게 final을 붙이는 경우가 많다.

## 추상클래스 VS 인터페이스

### 인터페이스

- 구성
  - 상수
  - 추상 메소드
  - 디폴트 메소드(java8 이상)
  - 스태틱 메소드(java8 이상)

```java
[public] interface Interface {
    [public static final] 자료형 상수명 = 값;
    [public abstract] 자료형 메서드명([매개변수, ...]);
    default 자료형 메소드명([매개변수, ...]){...} // 디폴트 메소드
    static 자료형 메소드명([매개변수, ...]){...}  // 정적메소드
}
```

- 인터페이스는 다중 상속이 가능

## Collection 프레임워크

컬렉션 클래스들과 인터페이스들의 집합

